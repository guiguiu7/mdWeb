## 缓存

> 为了提升系统性能，一般会将部分数据放入缓存中，加速访问。DB用于承担数据落盘的操作。

##### 哪些数据适合放入缓存

- 即时性、数据一致性要求不高的
- 访问量大而且更新频率不高的数据（读多，写少）

收到请求后——>读取缓存中数据——>命中——>返回结果

收到请求后——>读取缓存中数据——>未命中——>查询数据库——>将数据放入缓存——>返回结果

###### 不使用本地缓存：数据一致性、分布式下缓存不一致或者不存在、占用服务运行内存



## 分布式缓存

### 使用Redis

> 在SpringBoot2.0以后默认使用lettuce作为操作redis的客户端。并且使用netty进行网络通信。
>
> lettuce的BUG导致netty堆外内存溢出，netty没有指定堆外内存，默认使用-Xmx 100m

###### 不能只通过-Dio.netty.maxDirectMemory进行设置解决问题

- 升级lettuce客户端
- 切换使用jedis



### 缓存穿透

> **恶意用户或高并发请求查询的数据在缓存或者数据库中*不存在***，导致每次请求都会直接打到数据库，绕过缓存。由于缓存没有存储该请求的结果，所有这类请求都会绕过缓存，直接访问数据库，从而导致数据库承受巨大的压力。

###### 解决方法

- **缓存空结果**：如果查询的某个键在数据库中不存在，则将该键的查询结果（如 `null` 或空值）缓存起来，并设定一个较短的过期时间，防止该键反复查询打到数据库。
- **布隆过滤器**：使用布隆过滤器对所有可能存在的数据进行标记，所有请求先经过布隆过滤器进行校验，只有布隆过滤器认为存在的数据，才会去查询缓存或数据库。这样可以有效拦截掉绝大多数不存在的请求，防止这些请求绕过缓存直接打到数据库。



### 缓存雪崩

> 缓存雪崩是指**在某一时刻，*大量缓存同时失效***，导致大量请求直接打到数据库层，造成数据库压力骤增，甚至可能导致数据库崩溃、系统不可用的情况。

###### 解决方法

- **缓存过期时间分散化**：可以为不同的缓存键设置不同的失效时间（随机TTL），使得缓存的过期时间均匀分布，避免大量缓存同时失效。
- **缓存预热**：在系统上线前，提前将热点数据加载到缓存中，避免大量请求同时触发缓存未命中的情况。
- **降级策略**：在缓存雪崩时，可以采取限流、降级等策略，减缓数据库的压力。



### **缓存击穿**

> 缓存击穿是指**缓存中存储的某个热点数据在某一时刻失效**，大量并发请求同时去访问这个热点数据，导致所有请求打到数据库，造成数据库压力骤增的情况。

解决方法

- **热点数据永不过期**：对于特别重要的热点数据，可以考虑不设置缓存过期时间，让这些数据一直保存在缓存中。可以通过定时任务手动更新缓存中的数据来避免数据过期问题。

- **互斥锁（Mutex）机制**：为了解决在缓存失效瞬间，大量请求同时访问数据库的问题，可以通过加锁机制，保证同一时刻只有一个线程能访问数据库。其他线程需要等待该线程将新数据写入缓存后，再读取缓存。（==双检锁==）**使用Redisson来实现,详情见[分布式](./分布式.md)**

  ```java
  // 缓存中是否有值
  String value = redisTemplate.opsForValue().get(key);
  if (value == null) {
      // 获取分布式锁
      if (redisTemplate.opsForValue().setIfAbsent(lockKey, "lock", 10, TimeUnit.SECONDS)) {
          try {
              // Double-check 再次判断如果缓存中已经存在数据就无需查询数据库
              value = redisTemplate.opsForValue().get(key);
              if (value == null) {
                  // 查询数据库
                  value = database.get(key);
                  // 将结果写入缓存
                  redisTemplate.opsForValue().set(key, value, ttl, TimeUnit.SECONDS);
              }
          } finally {
              // 释放锁
              redisTemplate.delete(lockKey);
          }
      } else {
          // 等待锁释放后，再从缓存中读取数据
          Thread.sleep(100); // 自行调整等待时间
          value = redisTemplate.opsForValue().get(key);
      }
  }
  ```




### 缓存更新

- **双写模式**: 更新数据库后,再查一次数据库并将信息保存到缓存中 ( 需要使用锁将持久化与写缓存变成原子性)
  - 问题: 如果更新数据库操作出现网络问题,导致**先执行更新操作的持久化**在**其后更新操作持久化之后**才执行,就会出现缓存脏数据
- **失效模式**: 更新数据库后,直接删除缓存中的数据,等下次查询数据时再放入缓存
  - 问题: 线程1查询缓存为空,查询数据库要保持到缓存中时出现了延迟卡顿, 这时线程2刚好更新数据并且删除了缓存. 就会导致数据不一致

##### 解决方案

##### Cache Aside 策略 + 延迟双删

在更新数据时，我们可以不更新缓存，而是删除缓存中的数据，在读取数据时，发现缓存中没有，再从数据库中读取数据，更新到缓存中。这就是 **Cache Aside 策略（旁路缓存策略）**。

**延时双删**就是当我们第一次删除缓存之后，设置一个**定时任务或者MQ延迟消息**，设置在几秒之后再次删除缓存，这样就避免了出现这种极端情况导致的数据不一致窗口期大大加长。



### SpringCache + redis

##### 1.引入依赖

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-cache</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

##### 2.配置

```properties
spring.cache.type=redis
```

##### 3.@EnableCaching开启功能

##### 4.在需要缓存的方法上加上@Cacheable注解

默认生成的key为  缓存名::SimpleKey [] ==> testCache::SimpleKey []

缓存的value的值, 默认使用jdk序列化机制,将序列化后的值存入redis. 并且设置为永不过期

```java
@Cacheable("testCache")
public String testCache() {
    return "testCache";
}
```

#####  自定义

存活时间在properties设置

```properties
spring.cache.redis.time-to-live=60000
```

**配置RedisCacheConfiguration** (当使用该方法, 上面的properties设置的ttl就失效了)

```java
@EnableCaching
@Configuration
public class MyCacheManager {
    @Bean
    public RedisCacheConfiguration redisCacheConfiguration() {
        return RedisCacheConfiguration.defaultCacheConfig()
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new GenericJackson2JsonRedisSerializer())) // 配置缓存的序列化方式
                .entryTtl(Duration.of(60, ChronoUnit.SECONDS)) // 设置缓存TTL
                .computePrefixWith(cacheName -> cacheName); // 设置名字中间的分隔符
    }
}
```

##### 注解

- ##### @Cacheable（指定缓存分区以及key）

  ```java
  @Cacheable(value = "testCache", key = "'cache'")
  @Cacheable(value = "testCache", key = "#root.methodName")
  @Cacheable(value = "testCache", key = "#root.methodName", sync = true)  // 加syn
  ```

- ##### @CacheEvict（删除指定缓存）

  ```java
  @CacheEvict(value = "testCache", key = "'testCache'")  //删除指定分区下的指定key
  @CacheEvict(value = "testCache", allEntries = true)  //删除指定分区下所有数据
  ```

- ##### @Caching（组合多个缓存操作）

  ```java
  @Caching(evict = {
              @CacheEvict(value = "testCache", allEntries = true),
              @CacheEvict(value = "testCache", key = "'testCacheKey'")
      })
  ```

- ##### @CachePut 与 @Cacheable类似，@Cacheable执行方法前会检查缓存中是否有对应的值，如果有不执行方法直接返回缓存中的值；@CachePut不会进行检查，执行方法后会将缓存中的值进行更新；

