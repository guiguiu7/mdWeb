# 分布式

使用Spring cloud和spring cloud alibaba作为分布式开发

需要引入依赖管理

```xml
# 下面是依赖管理，相当于以后再dependencies里引spring cloud alibaba就不用写版本号， 全用dependencyManagement进行管理
<dependencyManagement>
     <dependencies>
         <dependency>
             <groupId>com.alibaba.cloud</groupId>
             <artifactId>spring-cloud-alibaba-dependencies</artifactId>
             <version>2.1.0.RELEASE</version>
             <type>pom</type>
             <scope>import</scope>
         </dependency>
     </dependencies>
</dependencyManagement>
```



### 一、分布式基础概念

## 1、微服务

> 服务架构风格，就像是把一个单独的应用程序开发成一套小服务，每个小服务运行在自己的进程中，并使用轻量级机制通信，通常是 HTTP API 这些服务围绕业务能力来构建， 并通过完全自动化部署机制来独立部署，这些服务使用不同的编程语言书写，以及不同数据存储技术，并保持最低限度的集中式管理
>

简而言之，拒绝大型单体应用，***业务边界进行服务微化拆分，每个服务独立部署运行。***



## 2、集群、分布式、节点

 分布式系统是若干独立计算机的集合，这些计算机对于用户来说像单个系统***分布式系统是建立网络之上的软件系统.***

- 集群：指的是将几台服务器集中在一起，*实现同一业务*
- 节点：集群中的一个*服务器*
- 分布式：指根据不同的业务分布在不同的地方

分布式中的每一个节点，都可以做集群，而集群并不一定就是分布式的、



## 3、远程调用

在分布式系统中, 各个服务可能处于不同主机, 但是服务之间不可避免的需要**互相协调**, 我们称之为 **远程调用**

SpringCloud中使用HTTP+JSON的方式来完成远程调用

Feign与注册中心 spring cloud feign 声明式远程调用 ***feign是一个声明式的HTTP客户端***，他的目的就是让远程调用更加简单。 给远程服务发的是HTTP请求。

##### 1.引入Open-Feign依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

##### 2.声明一个接口，告诉SpringCloud需要进行远程调用（需要确保被调用的服务有这个方法，并且注册到注册中心）

```java
@FeignClient("other-service")   //需要调用的其他服务的名称	
public interface XXFeignService {
    @RequestMapping("/xx")      //调用服务对应的方法
    public R memberCoupons();   //返回的数据类型R
}
```

##### 3.开启远程调用功能 @EnableFeignClients





## 4、负载均衡

负载均衡简单的说就是将用户的**请求平摊的分配到多个服务上**，从而达到系统的HA (高用)。

常见的负载均衡算法 :

- ***轮训算法*** : 为第一个请求选择健康池中的每一个服务器, 然后按顺序往后依次选择, 直到最后一个, 然后循环
- ***优先选择链接数最少***，也就是压力最小的后端服务器，在会话较长的情况下可以考虑采取这种方式



## 5、服务注册/发现 、注册中心

> A服务调用B服务，A服务不知道B服务当前在哪几台服务器上有，哪些正常的，哪些服务已经下线，解决这个问题可以引入注册中心. 如果某些服务下线，我们其他人可以实时的感知到其他服务的状态， 从而避免调用不可用的服务.

B服务上线时注册到服务中心，当A服务调用B服务获取注册中心的数据。

***使用SpringCloud Alibaba-Nacos[作为注册中心]***

##### 1.引入Nacos注册发现依赖

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>
```

##### 2.docker部署Nacos

```
docker run -d --name nacos -p 8848:8848 -e PREFER_HOST_MODE=hostname -e MODE=standalone nacos/nacos-server
```

##### 3.配置Nacos地址和微服务名称

```yml
spring:
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848 #nacos服务地址
  application:
    name: service-name #微服务名称
```

##### 4.使用@EnableDiscoveryClient 在服务启动类上开启服务注册、发现功能



## 6、配置中心

> 每一个服务最终都有大量配置，并且每个服务都可能部署在多个服务器上，我们经常需要变更配置，我们可以让每个服务在配置中心获取自己的配置。

***配置中心用来集中管理微服务的配置信息***  如Nacos

##### 使用Nacos作为配置中心<font color=red>可以在nacos中创建命名空间（默认为public）用于区分不同开发环境的配置</font>

##### 1.引入依赖

```xml
<dependency>
     <groupId>com.alibaba.cloud</groupId>
     <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
 </dependency>
```

##### 2.项目的resource中创建bootstrap.properties/bootstrap.yml

该文件是Springboot里规定的，优先级别高于application.properties

Nacos 默认会在启动的时候去配置中心上读取名为

```bash
${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}文件
```

nacos中的配置文件

```properties
# 项目的名字，对应nacos里的配置文件名
spring.application.name=service-name
spring.profiles.active=prod
# 配置中心的地址
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
# 指定命名空间
spring.cloud.nacos.config.namespace=xxxxxx
# 指定配置分组
spring.cloud.nacos.config.group=DEFAULT_GROUP
```

当有多个配置文件时

```properties
spring.cloud.nacos.config.ext-config[0].data-id=datasource.yml
spring.cloud.nacos.config.ext-config[0].group=dev
spring.cloud.nacos.config.ext-config[0].refresh=true

spring.cloud.nacos.config.ext-config[1].data-id=mybatis.yml
spring.cloud.nacos.config.ext-config[1].group=dev
spring.cloud.nacos.config.ext-config[1].refresh=true

spring.cloud.nacos.config.ext-config[2].data-id=other.yml
spring.cloud.nacos.config.ext-config[2].group=dev
spring.cloud.nacos.config.ext-config[2].refresh=true
```



## 7、服务熔断、服务降级

多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的“扇出”，如果扇出的链路上**某个微服务的调用响应时间过长，或者不可用**，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。

##### 7.1、服务熔断

> 设置服务的超时，当被调用的服务经常失败到达某个阈值，我们可以开启断路保护机制，后来的请求不再去调用这个服务，本地直接返回默认的数据

**熔断机制是对雪崩效应的一种微服务链路保护机制。**

当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而**熔断该节点微服务的调用，快速返回错误的响应信息。检测到该节点微服务调用响应正常后恢复调用链路**。

服务熔断解决如下问题：

- 当所依赖的对象不稳定时，能够起到快速失败的目的；
- 快速失败后，能够根据一定的算法动态试探所依赖对象是否恢复。

##### 7.2、服务降级

> 在运维期间，当系统处于高峰期，**系统资源紧张，我们可以让非核心业务降级运行**，降级：某些服务不处理，或者简单处理【抛异常，返回NULL，调用 Mock数据，调用 FallBack 处理逻辑】

**当某一时间内服务A的访问量暴增，而B和C的访问量较少，为了缓解A服务的压力，这时候需要B和C暂时关闭一些服务功能，去承担A的部分服务，从而为A分担压力，叫做服务降级**。

##### 使用Sentinel实现流量控制、熔断与降级的功能

#### 一、流控

##### 1.下载sentinel-dashboard.jar并运行

```bash
java -jar sentinel-dashboard-x.x.x.jar --port xxxx
```

##### 2.引入依赖

```xml
			<!--开启sentinel-->
<dependency>
	<groupId>com.alibaba.cloud</groupId>
	<artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
        <!--sentinel的图表统计-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

##### 3.编写配置文件

```properties
# 控制台的端口号
spring.cloud.sentinel.transport.dashboard=localhost:8080
spring.cloud.sentinel.transport.port=8719
#使用 * 表示允许所有管理端点都被暴露。即所有可用的 Actuator 端点都将通过 web 访问。
management.endpoints.web.exposure.include=*
## 开启远程调用支持
feign.sentinel.enabled=true

```

##### 4.自定义配置降级页面

```java
@Configuration
public class MySentinelConfig {

    public MySentinelConfig() {
        WebCallbackManager.setUrlBlockHandler((httpServletRequest, httpServletResponse, e) -> {
            R error = R.error("错误信息");
            httpMyServletResponse.setContentType("application/json;charset=utf-8");
            httpServletResponse.getWriter().write(JSON.toJSONString(error));
        });
    }
}

```

##### 5.多种定义受保护资源的方式（演示@SentinelResource和try-with-resource两种方式）

```java
    public R methodA(Long id) {
        //定义受保护的资源方式一
        try(Entry entry = SphU.entry("resourceName")) {
 					//自己的业务逻辑
        } catch (BlockException e) {
            log.info("{}:流控规则生效","resourceName");
        }
        return null;
    }
```

```java
@SentinelResource(value = "resourceName",blockHandler = "resourceNameHandler")
public R methodB() {
     	//自己的业务逻辑
}
// 触发流控执行的方法
public R resourceNameHandler(BlockException ex) {
        log.info("{}:流控规则生效","resourceName");
        return null;
}
```

##### sentinel也支持对于访问受保护资源的权限进行控制，例如假设我访问的路径中包含`resourceName`，则不允许访问，直接返回失败，则需要进行配置：

应用名为"blackList"并且设置为黑名单

```java
@Component
public class RequestOriginParserImpl implements RequestOriginParser {
    @Override
    public String parseOrigin(HttpServletRequest httpServletRequest) {
        String requestURI = httpServletRequest.getRequestURI();
        if (requestURI.contains("/resourceName")) {
                return "blackList"; //返回与黑名单应用名一致
        }
        return "whiteList";
    }
}
```



## 8、API 网关

> 网关的角色是作为一个 API 架构，用来保护、增强和控制对于 API 服务的访问
>
> API 网关是一个处于应用程序或服务（提供 REST API 接口服务）之前的系统，用来管理授权、访问控制和流量限制等，这样 REST API 接口服务就被 API 网关保护起来，对所有的调用者透明。因此，隐藏在 API 网关后面的业务系统就可以专注于创建和管理服务，而不用去处理这些策略性的基础设施。
>

网关的职责 :

- **请求接入** : 作为所有API接口服务请求的接入点
- **业务聚合** : 作为所有后端业务服务的聚合点
- **中介策略** : 实现安全、验证、路由、过滤、控制等策略
- **统一管理** : 对所有API服务和策略进行统一管理

##### 使用SpringCloud的Gateway组件作为网关

##### 1.引入依赖

```xml
<!--SpringCloud-nacos 注册中心-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</dependency>

<!--SpringCloud-nacos 配置中心-->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
</dependency>

<!-- 引入 Spring Cloud Gateway 相关依赖，使用它作为网关，并实现对其的自动配置 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>
```

##### 2.开启服务注册发现@EnableDiscoveryClient

##### 3.配置nacos注册中心

```properties
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
spring.application.name=service-gateway
server.port=88
```

##### 4.配置nacos配置中心

```properties
spring.application.name=service-gateway
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
spring.cloud.nacos.config.namespace=xxxxx
```

##### 5.配置网关路由规则

当请求携带参数为url并且值为baidu时跳转到https://www.baidu.com/

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: query_route
          uri: https://www.baidu.com/
          predicates:
            - Query=url,baidu

        - id: test_route
          uri: https://www.qq.com
          predicates:
            - Query=url,qq
```

## 9、链路追踪

> 微服务架构是通过业务来划分服务的，使用 REST 调用。对外暴露的一个接口，可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败。随着业务的不断扩张，服务之间互相调用会越来越复杂。
>
> **sleuth ： 链路追踪器**
> **zipkin：链路分析器（可视化）**

##### 9.1 Sleuth

- **Trace (一条完整链路–包含很多span(微服务接口))**

  由一组Trace Id（贯穿整个链路）相同的Span串联形成一个树状结构。为了实现请求跟踪，当请求到达分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的标识（即TraceId），同时在分布式系统内部流转的时候，框架始终保持传递该唯一值，直到整个请求的返回。那么我们就可以使用该***唯一标识将所有的请求串联起来，形成一条完整的请求链路***。

- **Span**

  代表了***一组基本的工作单元***。为了**统计各处理单元的延迟，当请求到达各个服务组件**的时候，也通过一个唯一标识（SpanId）来标记它的开始、具体过程和结束。通过SpanId的开始和结束时间戳，就能统计该span的***调用时间***，除此之外，我们还可以获取如事件的名称。请求信息等元数据。

- **Annotation**

  用它**记录一段时间内的事件，内部使用的重要注释**：

  - cs（Client Send）客户端发出请求，开始一个请求的生命

  - sr（Server Received）服务端接受到请求开始进行处理， sr－cs = 网络延迟（服务调用的时间）

  - ss（Server Send）服务端处理完毕准备发送到客户端，ss - sr = 服务器上的请求处理时间

  - cr（Client Reveived）客户端接受到服务端的响应，请求结束。 cr - sr = 请求的总时间

##### 9.2 Zipkin

> 它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储展现、查找和我们可以使用它来收集各个服务器上请求链路的跟踪数据，并通过它提供的REST API接口来辅助我们查询跟踪数据以实现对分布式系统的监控程序，从而及时地发现系统中出现的延迟升高问题并找出系统性能瓶颈的根源,除了面向开发的 API 接口之外，它也提供了方便的UI组件来帮助我们直观的搜索***跟踪信息和分析请求链路明细***。
>
> **Zipkin** 提供了可插拔数据存储方式：In-Memory、MySql、Cassandra 以及 Elasticsearch。

主要由 4 个核心组件构成：

- **Collector**：收集器组件，它主要用于**处理从外部系统发送过来的跟踪信息**，将这些信息转换为Zipkin 内部处理的 Span 格式，以**支持后续的存储、分析、展示等功能**。
- **Storage**：存储组件，它主要对**处理收集器接收到的跟踪信息**，默认会将这些信息存储在**内存**中，我们也可以修改此存储策略，通过使用其他存储组件将跟踪信息存储到数据库中。
- **RESTful API**：API 组件，它主要用来**提供外部访问接口**。比如给客户端展示跟踪信息，或是外接系统访问以实现监控等。
- **Web UI**：UI 组件，基于 API 组件实现的上层应用。通过 UI 组件用户可以方便而有直观地查询和分析跟踪信息。

**Zipkin分为两端，一个是 Zipkin 服务端，一个是 Zipkin 客户端，客户端也就是微服务的应用。**

==**集成Sleuth+Zipkin**==

##### 1.下载并启动zipkin-service

```bash
java -jar zipkin-server-2.12.9-exec.jar
```

##### 2.引入依赖

```xml
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-sleuth</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-zipkin</artifactId>
</dependency>
```

##### 3.添加配置

```yaml
#配置zipkin
  zipkin:
    base-url: http://192.168.31.60:9411
    discovery-client-enabled: false  # 不要让nacos把zipkin注册进去（可以不写）
  sleuth:
    sampler:
      probability: 1.0

```

##### 如果要将zipkin数据持久化

```sql
CREATE DATABASE `zipkin` /*!40100 DEFAULT CHARACTER SET utf8 */;
use zipkin;
 
CREATE TABLE IF NOT EXISTS zipkin_spans (
  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT 'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit',
  `trace_id` BIGINT NOT NULL,
  `id` BIGINT NOT NULL,
  `name` VARCHAR(255) NOT NULL,
  `remote_service_name` VARCHAR(255),
  `parent_id` BIGINT,
  `debug` BIT(1),
  `start_ts` BIGINT COMMENT 'Span.timestamp(): epoch micros used for endTs query and to implement TTL',
  `duration` BIGINT COMMENT 'Span.duration(): micros used for minDuration and maxDuration query',
  PRIMARY KEY (`trace_id_high`, `trace_id`, `id`)
) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;
 
ALTER TABLE zipkin_spans ADD INDEX(`trace_id_high`, `trace_id`) COMMENT 'for getTracesByIds';
ALTER TABLE zipkin_spans ADD INDEX(`name`) COMMENT 'for getTraces and getSpanNames';
ALTER TABLE zipkin_spans ADD INDEX(`remote_service_name`) COMMENT 'for getTraces and getRemoteServiceNames';
ALTER TABLE zipkin_spans ADD INDEX(`start_ts`) COMMENT 'for getTraces ordering and range';
 
CREATE TABLE IF NOT EXISTS zipkin_annotations (
  `trace_id_high` BIGINT NOT NULL DEFAULT 0 COMMENT 'If non zero, this means the trace uses 128 bit traceIds instead of 64 bit',
  `trace_id` BIGINT NOT NULL COMMENT 'coincides with zipkin_spans.trace_id',
  `span_id` BIGINT NOT NULL COMMENT 'coincides with zipkin_spans.id',
  `a_key` VARCHAR(255) NOT NULL COMMENT 'BinaryAnnotation.key or Annotation.value if type == -1',
  `a_value` BLOB COMMENT 'BinaryAnnotation.value(), which must be smaller than 64KB',
  `a_type` INT NOT NULL COMMENT 'BinaryAnnotation.type() or -1 if Annotation',
  `a_timestamp` BIGINT COMMENT 'Used to implement TTL; Annotation.timestamp or zipkin_spans.timestamp',
  `endpoint_ipv4` INT COMMENT 'Null when Binary/Annotation.endpoint is null',
  `endpoint_ipv6` BINARY(16) COMMENT 'Null when Binary/Annotation.endpoint is null, or no IPv6 address',
  `endpoint_port` SMALLINT COMMENT 'Null when Binary/Annotation.endpoint is null',
  `endpoint_service_name` VARCHAR(255) COMMENT 'Null when Binary/Annotation.endpoint is null'
) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;
 
ALTER TABLE zipkin_annotations ADD UNIQUE KEY(`trace_id_high`, `trace_id`, `span_id`, `a_key`, `a_timestamp`) COMMENT 'Ignore insert on duplicate';
ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`, `span_id`) COMMENT 'for joining with zipkin_spans';
ALTER TABLE zipkin_annotations ADD INDEX(`trace_id_high`, `trace_id`) COMMENT 'for getTraces/ByIds';
ALTER TABLE zipkin_annotations ADD INDEX(`endpoint_service_name`) COMMENT 'for getTraces and getServiceNames';
ALTER TABLE zipkin_annotations ADD INDEX(`a_type`) COMMENT 'for getTraces and autocomplete values';
ALTER TABLE zipkin_annotations ADD INDEX(`a_key`) COMMENT 'for getTraces and autocomplete values';
ALTER TABLE zipkin_annotations ADD INDEX(`trace_id`, `span_id`, `a_key`) COMMENT 'for dependencies job';
 
CREATE TABLE IF NOT EXISTS zipkin_dependencies (
  `day` DATE NOT NULL,
  `parent` VARCHAR(255) NOT NULL,
  `child` VARCHAR(255) NOT NULL,
  `call_count` BIGINT,
  `error_count` BIGINT,
  PRIMARY KEY (`day`, `parent`, `child`)
) ENGINE=InnoDB ROW_FORMAT=COMPRESSED CHARACTER SET=utf8 COLLATE utf8_general_ci;

```

```bash
java -jar zipkin-server-2.23.2-exec.jar --STORAGE_TYPE=mysql --MYSQL_HOST=192.168.31.60 --MYSQL_TCP_PORT=3306 --MYSQL_DB=zipkin --MYSQL_USER=root --MYSQL_PASS=123@qwe

MYSQL_HOST：本机IP
MYSQL_TCP_PORT：端口号
MYSQL_DB：数据库名
MYSQL_USER：用户名
MYSQL_PASS：密码
```



## 事务

##### 本地事务

```java
@Service
public class transactional {
    // 同一个类中的事务方法调用不会生效，原因是Spring AOP的代理机制。
    // 解决方法是将事务方法放在不同的类中，或者通过注入当前类的实例来调用事务方法。
    @Transactional
    public void a() {
        //当a回滚，b会进行回滚，但c不会回滚
        b(); //由于事务b设置了REQUIRED传播行为，所以会加入到当前事务中（默认为REQUIRED）
        c(); //由于事务c设置了REQUIRES_NEW传播行为，所以会开启一个新的事务
    }
    @Transactional(propagation = Propagation.REQUIRED)
    public void b() {
    }
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void c() {
    }
}
```

###### 由于事务使用代理对象来控制，如果当三个方法都在同一个Service下，会绕过代理导致bc的注解会失效，都是公用a事务。当不在同一个Service下bc的注解会与上述代码一致

##### 解决：使用代理对象来调用事务方法

##### 1.引入spring-boot-starter-aop依赖

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

##### 2.@EnableAspectJAutoProxy(exposeProxy = true)开启AspectJ动态代理功能，并且对外暴露代理对象

通过代理对象调用方法，便可以解决上述问题

```java
MyClss o = (MyClss) AopContext.currentProxy();
```



## 分布式事务

> 分布式系统中使用本地事务，远程调用其他服务成功后，（在后续发生异常进行回滚/远程调用方法执行成功，由于网络原因导致调用方回滚），远程调用的方法不会进行回滚操作，导致数据不一致。

##### CAP 理论

- 一致性（Consistency）
- 可用性（Availability）
- 分区容错性（Partition tolerance）

**在分布式事务中，一致性、可用性和分区容错不可兼得。分布式系统只能为CP或AP**

> ##### Raft算法动画演示地址
>
> https://thesecretlivesofdata.com/raft/



##### BASE 理论

- Basically Available（基本可用）
- Soft state（柔软状态）
- Eventually consistent（最终一致性）

BASE是对CAP中**一致性和可用性权衡的结果**，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的。

其核心思想是：**即使无法做到强一致性**（Strong consistency），但每个应用都可以根据自身的业务特点，**采用适当的方式来使系统达到最终一致性**（Eventual consistency）。



#### 使用SEATA作为分布式事务解决方案

##### 1.每个服务建立UNDO_LOG表

##### 2.安装TC：seata-server，修改conf/registry.conf配置文件并启动

##### 3.引入依赖

```xml
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-seata</artifactId>
</dependency>
```

##### 4.配置

```yaml
seata:
  tx-service-group: my_tx_group # 事务组名，需与TC配置匹配
  registry: # 注册中心
    # 配置 seata 的注册中心, 告诉 seata client 怎么去访问 seata server 事务协调者进行通信
    type: nacos
    nacos:
      server-addr: 172.16.10.132:8847 # seata-server 所在的注册中心地址
      application: seata-server # 指定 seata-server 在注册中心的 服务名， (默认 seata-server)
      group: SEATA_GROUP # 默认 SEATA_GROUP
  config:
    # 配置 seata 的配置中心，可以读取关于 seata client 的一些配置，即 "seata\seata\script\config-center\config.txt" 中的配置
    type: nacos
    nacos: # 配置中心
      server-addr: 172.16.10.132:8847
      group: SEATA_GROUP
```

##### 5.@GlobalTransactional // 开启全局事务



#### 使用RabbitMQ实现分布式事务

详情使用见 [RabbitMQ](./RabbitMq.md)



## 分布式锁

#### 使用Redisson实现分布式锁

带有try的方法为非阻塞的，会返回boolean值用于判断是否获取成功

##### 1.导入依赖

```xml
<dependency>
	<groupId>org.redisson</groupId>
	<artifactId>redisson</artifactId>
</dependency>
```

##### 2.配置

```java
@Configuration
public class MyRedissonConfig {
    @Bean(destroyMethod = "shutdown")
    public RedissonClient redissonClient() {
        // 创建 RedissonClient 实例
        Config config = new Config();
        config.useSingleServer().setPassword("admin@2025").setAddress("redis://103.210.237.3:6379");
        return Redisson.create(config);
    }
}
```

##### 3.使用

```java
void testRedisson(){
        System.out.println(redissonClient);
        RLock lock = redissonClient.getLock("testLock");
        lock.lock();
        try {
            System.out.println("获得锁"+Thread.currentThread());
            Thread.sleep(5000L);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }finally {
            lock.unlock();
        }
    }
```

##### lock()为阻塞式等待。默认加锁时间为30S。

- **锁会自动续期**，如果业务时间过长，运行期间会自动给锁续上30S。不必担心业务时间长，锁自动过期被删除。（前提是**没有显示的设置自动解锁时间**，LockWatchdogTimeout默认时间为30*1000，每过30 / 3 => 10S 会自动续期）
- 加锁的业务只要**运行完成，就不会给锁续期**，即使不手动解锁，锁默认在 30S以后过期。（避免了死锁）

##### 推荐使用`lock.lock(10L, TimeUnit.SECONDS);`设置过期时间，省去自动续期的操作。（需要保证时间内能完成业务）



##### ReadWriteLock的读锁为共享锁，写锁为互斥锁。（无论写锁在读锁执行的前后，都会进行堵塞）

```java
void RWLock() {
        RReadWriteLock testRWLock = redissonClient.getReadWriteLock("testRWLock");
        RLock lock = testRWLock.readLock();
        lock.lock();
        try {
            System.out.println("获得读锁"+Thread.currentThread().getId());
            Thread.sleep(5000L);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            lock.unlock();
            System.out.println("释放读锁"+Thread.currentThread().getId());
        }
    }
```



##### 信号量 (Semaphore)

tryAcquire()使信号量默认减一,成功返回true,失败反之 

也可以通过release()释放信号量

```java
void testSem(){
        RSemaphore testSem = redissonClitryent.getSemaphore("testSem");
        testSem.trySetPermits(3);
        boolean b = testSem.tryAcquire();
        if (b){
            System.out.println("获得信号量"+Thread.currentThread().getId());
        }else {
            System.out.println("获取信号量失败"+Thread.currentThread().getId());
        }
    }
```



##### 闭锁 (CountDownLatch)

当计数器归零时,执行后续操作  使用await阻塞等待计数器归零

```java
void testCDL() {
        RCountDownLatch testCDL = redissonClient.getCountDownLatch("testCDL");
        try {
            testCDL.countDown();  // 减一
            System.out.println("线程" + Thread.currentThread().getId() + "执行完毕，CDL计数器-1");
            testCDL.await();  //当所有闭锁执行完成,才执行后续代码
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        System.out.println("CDL 计数器已归零，所有线程可以继续执行");
    }
    
void threadRun() throws InterruptedException {
        RCountDownLatch testCDL = redissonClient.getCountDownLatch("testCDL");
        testCDL.trySetCount(5);
        for (int i=0; i<5; i++){
            new Thread(this::testCDL).start();
        }
        Thread.sleep(12000L);
    }
```

