# 多线程

> ⼀个线程就是⼀个 “执行流”。 **每个线程之间都可以按照顺序执行自己的代码. 多个线程之间 “同时” 执行着多份代码**,main()⼀般被称为**主线程（Main Thread）**。

##### 进程和线程的区别

- 进程是包含线程的. 每个进程至少有⼀个线程存在，即主线程。
- 进程和进程之间不共享内存空间. 同⼀个进程的线程之间共享同⼀个内存空间.
- 进程是系统分配资源的最小单位，线程是系统调度的最小单位。
- ⼀个进程挂了⼀般不会影响到其他进程. 但是⼀个线程挂了, 可能把同进程内的其他线程⼀起带走(整 个进程崩溃)



## 创建线程

### 方法一：继承Thread类

```java
class MyThread extends Thread { 
    @Override
    public void run() {
        System.out.println("这⾥是线程运⾏的代码");
    }
}
public class Test {
    public static void main(String[] args)  {
        MyThread t = new MyThread();
        t.start();
    }
}
```

### 方法二：实现Runnable接口

```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("这⾥是线程运⾏的代码");
    }
}
public class Test {
    public static void main(String[] args)  {
        Thread t = new Thread(new MyRunnable());
        t.start();
    }
}
```

*方法一与方法二可以使用匿名内部类编写*

### 方法三：使用Callable和FutureTask实现（有返回值）

```java
public class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        System.out.println("Callable is running in thread: " + Thread.currentThread().getName());
        return "hello from Callable";
    }
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        FutureTask<String> futureTask = new FutureTask<>(new MyCallable());
        new Thread(futureTask).start();  // 实现多线程的关键
        System.out.println(futureTask.get());  // 获取返回值，但会阻塞
    }
}
```

### 方法四：使用线程池（推荐）

##### 7大参数

1. **corePoolSize**：核心线程数。一直存在除非allowCoreThreadTimeOut为true（线程存活时间使用keepAliveTime）。**线程创建采用懒加载**，没有超过限制的线程数时使用一个只创建一个线程。
2. **maximumPoolSize**：最大线程数。
3. **keepAliveTime**：存活时间。如果线程数大于corePoolSize，释放超过存活时间空闲的线程。
4. **unit**：时间单位。
5. **BlockingQueue<Runnable>**：阻塞队列。超出线程数的任务将会放入队列中，如果有空闲队列取出任务执行。
6. **ThreadFactory**：创建线程的工厂。
7. **RejectedExecutionHandler**：拒绝策略。如果阻塞队列已满，按照拒绝策略进行拒绝。

##### 执行过程

1. 线程池创建，任务到来创建线程执行。
2. core满了，将任务放入阻塞队列。空闲的core会自己获取队列中的任务。
3. 当阻塞队列满了，创建新的线程直到指定的maximumPoolSize数量。
4. 如果最大线程也满了，就会执行拒绝策略。
5. 当max中的任务执行结束，释放超过存活时间的空闲线程直到与core数量一致。（没有设置allowCoreThreadTimeOut）

##### 创建线程池

> 线程池是一种利用池化技术思想来实现的线程管理技术，主要是为了**复用线程、便利地管理线程和任务**、并将线程的创建和任务的执行解耦开来。我们可以创建线程池来复用已经创建的线程来**降低频繁创建和销毁线程所带来的资源消耗**。

不推荐使用Executors，它有**无边界资源分配**问题，会导致OOM

```java
/**
 * @author Gwynliu7
 */
public class MyThreadPool{
    // 创建一个线程池
    private final ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
            5, // 核心线程数
            10, // 最大线程数
            60L, // 空闲线程存活时间
            java.util.concurrent.TimeUnit.SECONDS, // 时间单位
            new java.util.concurrent.LinkedBlockingQueue<>(10), // 队列类型并设置队列最大数量
            new DefaultThreadFactory("test"), // 线程工厂
            new ThreadPoolExecutor.AbortPolicy() // 拒绝策略
    );
    Runnable runnable = () -> {
        System.out.println("1" + Thread.currentThread());
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    };
    public void testPoll() {
        threadPoolExecutor.execute(runnable);
    }

    public static void main(String[] args) {
        MyThreadPool myThreadPool = new MyThreadPool();
        for (int i = 0; i < 100; i++){
            myThreadPool.testPoll();
        }
    }
}
```

- Executors工厂类概述（不推荐使用，有OOM风险）

- Executors是Java中用于创建线程池的工厂类，它提供了一系列的静态工厂方法，用于创建不同类型的线程池。这些工厂方法隐藏了线程池的复杂性，使得线程池的创建变得非常简单。Executors工厂类提供的线程池有以下几种类型：

1. newCachedThreadPool()：创建一个可缓存的线程池。这个线程池的线程数量可以根据需要自动扩展，如果有可用的空闲线程，就会重用它们；如果没有可用的线程，就会创建一个新线程。适用于执行大量的短期异步任务。
2. newFixedThreadPool(int threads)：创建一个固定大小的线程池，其中包含指定数量的线程。线程数量是固定的，不会自动扩展。适用于执行固定数量的长期任务。
3. newSingleThreadExecutor()：创建一个单线程的线程池。这个线程池中只包含一个线程，用于串行执行任务。适用于需要按顺序执行任务的场景。
4. newScheduledThreadPool(int corePoolSize)：创建一个固定大小的线程池，用于定时执行任务。线程数量固定，不会自动扩展。适用于定时执行任务的场景。
5. newSingleThreadScheduledExecutor()：创建一个单线程的定时执行线程池。只包含一个线程，用于串行定时执行任务
6. newWorkStealingPool(int parallelism)：创建一个工作窃取线程池，线程数量根据CPU核心数动态调整。适用于CPU密集型的任务。
