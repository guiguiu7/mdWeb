# 锁

> **定义：锁是多线程编程中的一种同步机制，用于控制对共享资源的访问。**
>
> **概念：锁可以确保多个线程之间对共享资源的访问是互斥的，也就是同一时刻只有一个线程能够访问被保护的共享资源，从而避免并发访问带来的数据不一致性和竞态条件等问题，是解决线程安全问题常用手段之一。**

1. ##### 内置锁： 

   - 使用关键字synchronized实现。
   - 可以对方法或代码块进行同步，被同步的代码同一时刻只有一个线程可以执行其中的代码。

2. ##### 显式锁：

   - 使用java.util.concurrent.locks包下锁机制实现，比如ReentrantLock。
   - 提供了更加灵活的控制，需要显式的用lock()方法加锁和unlock()方法释放锁。

3. ##### 条件锁：

   - 使用java.util.concurrent.locks包下的Condition接口和ReentrantLock实现
   - 允许线程在某个特定条件满足时等待或唤醒

4. ##### 读写锁：

   - 使用java.util.concurrent.locks包下的ReentrantReadWriteLock实现。
   - 允许多个线程同时读共享资源，但只允许一个线程进行写操作。

5. ##### StampedLock：

   - 在Java8中引入的新型锁机制，也是在java.util.concurrent.locks包下。
   - 提供了三种模式：写锁、悲观读锁和乐观读锁。

6. ##### 无锁： 

   - 也就是我们常说的乐观锁，基于原子操作实现的锁机制，比如CAS算法。
   - 避免了传统锁机制的线程阻塞和切换开销。



# synchronized关键字

> - 互斥性：同一时间，只有一个线程可以获得锁，获得锁的线程才能执行被synchronized保护的代码片段。
> - 阻塞性：未获得锁的线程只能阻塞，等待锁释放
> - 可重入性：如果一个线程已经获得锁，在锁未释放前，再次请求锁的时候，是必然可以获取到的。

##### 可以修饰普通方法：锁的是当前实例

修饰方法：也就成了同步方法，它的常量池中会有一个**ACC_SYNCHRONIZED**标志。当某个线程要访问某个方法的时候，会检查是否有设置ACC_SYNCHRONIZED，如果有设置，则**需要先获得监视器锁（Monitor）**，然后开始执行方法，**方法执行之后再释放监视器锁（Monitor）**。这时如果其它线程来请求执行方法，会因为**无法获得监视器（Monitor）锁而被阻塞住**。（如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前**监视器锁（Monitor）会被自动释放**）

```java
public synchronized void doSomething(){}
```

##### 修饰静态方法：锁的是当前类的Class对象

```java
public static synchronized void doSomething(){}
```

##### 修饰代码块：锁的是括号里面的内容

修饰代码块：同步代码块是使用**monitorenter和monitorexit两个指令实现的**。我们可以把**执行monitorenter理解为加锁**，执行**monitorexit理解为释放锁**。每个对象维护着一个记录**被锁次数的计数器**，未被锁定的对象的计数器为0，当一个线程获得锁（执行了monitorenter指令）后，**计数器会自增**为1，当同一个线程再次获得该对象的锁时，计数器会再次自增。同一个线程释放锁（执行monitorexit指令）时，**计数器自减**，**当计数器为0的时候，锁被释放**，其他线程才能获得锁。（防止在**第一个monitorexit执行之前程序发生异常，导致锁不会被释放的情况**）

```java
synchronized (任意对象){}
```

### 锁消除

> **概念： 在没有操作共享数据的位置加锁，JVM会直接优化掉，没有锁。**

```java
// 优化前
public void doSomething(){
     Object o = new Object();
     synchronized (o){
        System.out.println(o);
    }
}

// 优化后
public void doSomething(){
     Object o = new Object();
     System.out.println(o);
}
```

### 锁粗化

> **概念：将锁的覆盖范围提升，避免频繁的竞争和释放锁资源** （避免反复加锁，消耗性能）

```java
// 优化前
public void doSomething(){
    for (int i = 0; i < 1000; i++) {
        synchronized (this){
            System.out.println("do something");
        }
    }
}

// 优化后
public void doSomething(){
    synchronized (this) {
        for (int i = 0; i < 1000; i++) {
            System.out.println("do something");
        }
    }
}
```

### 自适应自旋锁、自旋锁

> ###### 概念：
>
> ###### 自旋锁（JDK1.4）：当线程尝试获取锁时，如果锁已经被其他线程占用，那么该线程会不断地循环检查锁是否可用（自旋），而不是放弃CPU的执行权。
>
> ###### 自适应自旋锁（JDK1.6）：自适应就意味着自旋的时间不再是固定的了，而是由前一次在同一把锁上的自旋时间及锁的拥有者的状态来决定的。

### 锁升级（无锁->偏向锁->轻量级锁->重量级锁）

> **在JDK1.6之前，如果当前对象没有被锁住，线程会获取锁并继续执行，反之，线程就会进入阻塞状态，直到锁被释放。这种锁的实现方式就被成为“重量级锁”，因为锁的获取和释放都需要在操作系统层面上进行线程的阻塞和唤醒，而这些操作会带来很大的开销。**

- **无锁**：当**第一个线程第一次访问一个对象的同步块**时，JVM会在**对象头中设置该线程的Thread ID**，并将对象头的**状态位设置为“偏向锁”**。这个过程称为“偏向”，**表示对象当前偏向于第一个访问它的线程**。
- **偏向锁**：指在只有**一个线程访问对象**的情况下，也就是没有竞争，可以**直接执行代码**，并在对象头中**记录该线程的ID作为偏向锁的持有者**，如果**出现竞争，那就升级为轻量级锁**。
- **轻量级锁**：当一个线程访问该对象时，JVM会将对象头中的**Mark Word复制一份到线程栈**中，并在对象头中**存储线程栈中的指针**。此时如果另外一个线程想要访问该对象，会发现该对象已经处于轻量级锁状态，于是开始尝试使用CAS操作将对象头中的指针替换成自己的指针。**自旋一定次数后(JDK1.8最多自旋15次）**，如果替换成功，则该线程获取锁成功，反之，升级为重量级锁。
- **重量级锁**：当锁升级到重量级锁时，JVM会将该对象的锁编程一个重量级锁，并在对象头中**记录指向等待队列的指针**。此时如果一个线程想要获取锁，需要先进入等待队列，等待锁被释放。当锁被释放时，**JVM会从等待队列中选择一个线程唤醒，并将该线程设置为“就绪”状态**。



## ReentrantLock

> 使用synchronized关键字将会***隐式地***获取或释放，这种方式简化了同步管理，但扩展性没有显式的好。

### ReentrantLock类实现及常用方法

**ReentrantLock内部是基于AbstractQueuedSynchronizer(简称AQS)实现的，其内部是一个双向队列，还有一个volatile修饰的int类型的state，state=0表示当前锁没有被占有，state>0表示当前已有线程持有锁**。

```java
public static void main(String[] args) {
     Lock lock = new ReentrantLock();
     //获取锁
     lock.lock();
     try {
        //代码逻辑
     } finally {
         //释放锁
         lock.unlock();
    }
}
```





### 公平锁和非公平锁

##### syncchronized关键字只有非公平锁，而ReentrantLock可实现非公平锁和公平锁。

> 非公平锁：多个线程不按照申请锁的顺序去获得锁，而是同时直接去尝试获取锁，获取不到，再进入队列等待。
>
> 公平锁：多个线程按照申请锁的**顺序**去获得锁，所有线程都在队列里排队，这样就保证队列中的第一个线程先获得锁。

```java
//只需要在new的时候指定其构造函数为true，就是公平锁
public ReentrantLock(boolean fair) {
   sync = fair ? new FairSync() : new NonfairSync();
}
```

**非公平锁**：优点是减少了cpu唤醒线程的开销，整体的吞吐量会高一点。但它可能会导致队列中排队的线程一直获取不到锁或长时间获取不到，活活饿死。
**公平锁**：优点是所有的线程都能得到资源，不会饿死在队列中。但它的吞吐量相较非公平锁而言，就下降了很多，队列里面除了第一个线程，其它线程都会阻塞，cpu唤醒阻塞线程的开销是很大的缺点。



### 可重入性

> 所谓重入锁，是**指一个线程拿到锁后，还可以多次获取同一把锁**，而不会因为该锁已经被持有（尽管是自己持有的）而陷入等待状态。之前说的**sychronized也是可重入锁**。
>
> ReentrantLock加锁的时候，看下当前持有锁的线程和当前请求的线程是否同一个，一样就可重入了。只需要简单的讲state加1，记录当前重入的次数即可。同时，在锁释放的时候，需要确保state=0的时候才执行释放的动作，简单的说就是**重入多少次就得释放多少次**。

```java
public class Chopsticks {
    boolean getOne=false;
    boolean getAnother=false;
    //拿筷子，获取锁，该锁是当前Chopsticks对象
    public synchronized void getOne() {
        getOne=true;
        System.out.println(Thread.currentThread().getName()+"拿到了一根筷子。");
        //if语句块调用了另外的同步方法，需要再次获取锁，而该锁也是当前Chopsticks对象
        if(getAnother) {
            //有两根筷子，吃饭
            canEat();
            //吃完放下两根筷子
            getOne=false;
            getAnother=false;
        }else {
            //只有一根筷子，去拿另一根，然后吃饭
            getAnother();
        }       
    }
    public synchronized void getAnother() {
        getAnother=true;
        System.out.println(Thread.currentThread().getName()+"拿到了一根筷子。");
        if(getOne) {
            //有两根筷子，吃饭
            canEat();
            //吃完放下两根筷子
            getOne=false;
            getAnother=false;
        }else {
            //只有一根筷子，去拿另一根，然后吃饭
            getOne();
        }       
    }
    public synchronized void canEat() {
            System.out.println(Thread.currentThread().getName()+"拿到了两根筷子，开恰！");
    }
}
```

```java
public class testChopstick {
    public static void main(String[] args) {
        Chopsticks chopsticks=new Chopsticks();
        //线程A,模拟人A
        Thread A=new Thread(new Runnable() {        
            @Override
            public void run() {
                chopsticks.getOne();
            }
        });
        //线程B，模拟人B
        Thread B=new Thread(new Runnable() {        
            @Override
            public void run() {
                chopsticks.getAnother();
            }
        });
        A.start();
        B.start();
    }
}
```

两个线程都执行的是同一个对象chopsticks中的方法，这两个同步方法在**执行时将会获取同样的锁**；当线程1抢到CPU进入getOne时获取锁然后执行代码，如果线程1还未执行完毕就被线程2抢占了CPU，当线程2进入getAnother时发现锁在线程1那里，于是线程2等待；线程1重新拿到CPU继续执行代码，进入getAnother方法获取锁，**发现锁就在自己这里，于是继续执行，这就是可重入锁**。可重入锁避免了死锁的发生，避免线程因获取不了锁而进入永久等待状态。



### ReentrantLock与synchronized的对比

两个的相同点是，都是用于**线程同步控制**，且都是**可重入锁**，但也有很多不同点：

- synchronized是**Java内置特性**，而ReentrantLock是通过**Java代码实现的**。
- synchronized可以**自动获取/释放锁**，而ReentrantLock需要**手动获取/释放锁**。
- synchronized的**锁状态无法判断**，而ReentrantLock可以用**tryLock()方法判断**。
- synchronized通过**notify()和notifyAll()唤醒一个和全部线程**，而ReentrantLock可以结合**Condition选择性的唤醒线程**。
- 在3.1小节提到过ReentrantLock的常用方法，所以它还具有响应中断、超时等待、tryLock()非阻塞尝试获取锁等特性。
- ReentrantLock可以**实现公平锁和非公平锁**，而synchronized只是**非公平锁**。



## Condition接口

> Condition接口也来自java.util.concurrent.locks包下，任意一个Java对象，都拥有一组**监视器方法（Object）**，主要包括wait、wait(long timeout)、notify()和notifyAll()方法，这些方法**与sychronized关键字配合，可以实现等待/通知模式**。Condition接口也提供了类似Object的监视器方法，**与Lock配合可以实现等待/通知模式**。
>
> ##### 每次使用lock.newCondition()都会创建一个FIFO的队列。condition. await()方法会释放当前线程的锁，并将线程放入队列中挂起。condition. single()方法会从队列中取出一个线程，并重新进行锁的竞争。(锁的竞争是根据lock是否为公平锁有关)

##### 交替打印ABC

当启动三个线程后，会调用方法抢占线程，num的值为1，即使B、C抢占到锁会判断num值是否相等，显然只有A满足条件，其他线程进入队列等待并释放锁。所以只有A符合条件先执行，打印A并且设置num值为2，唤醒B线程。以此类推。

```java
public class ABC {
    //1表示A 2表示B 3表示C
    private int num=1;
    //创建Lock
    private Lock lock=new ReentrantLock();
    //创建Condition
    Condition conditionA=lock.newCondition();
    Condition conditionB=lock.newCondition();
    Condition conditionC=lock.newCondition();
    //打印A
    public void printA() {
        //上锁
        lock.lock();
        try {
            if (num!=1){
                //如果不是A
                try {
                    //当前线程进入队列等待，并释放锁（也就是不往下走了，直到被唤醒）
                    conditionA.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //打印A
            System.out.println("A");
            //将标记该为“B”
            num=2;
            //唤醒B
            conditionB.signal();
        }finally {
            lock.unlock();
        }
    }
    //B和C的打印就不一一介绍了
    public void printB() {
        lock.lock();
        try {
            if (num!=2){
                try {
                    conditionB.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("B");
            num=3;
            conditionC.signal();
        }finally {
            lock.unlock();
        }
    }
    //打印C
    public void printC(){
        lock.lock();
        try {
            if (num!=3){
                try {
                    conditionC.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("C");
            num=1;
            conditionA.signal();
        }finally {
            lock.unlock();
        }
    }
}
```

```java
public static void main(String[] args) {
        ABC abc=new ABC();
        new Thread(()->{
            for (int i = 0; i < 20; i++) {
                abc.printA();
            }
        }).start();
        new Thread(()->{
            for (int i = 0; i < 20; i++) {
                abc.printB();
            }
        }).start();
        new Thread(()->{
            for (int i = 0; i < 20; i++) {
                abc.printC();
            }
        }).start();
}
```

##### 生产者与消费者

```java
ReentrantLock lock = new ReentrantLock();
Condition notFull = lock.newCondition();   // 队列未满时的等待队列（生产者专用）
Condition notEmpty = lock.newCondition();  // 队列非空时的等待队列（消费者专用）

// 生产者线程
void produce() throws InterruptedException {
    lock.lock();
    try {
        while (queue.isFull()) {
            notFull.await();  // 生产者进入 notFull 的队列
        }
        queue.add(item);
        notEmpty.signal();    // 从 notEmpty 队列唤醒一个消费者
    } finally {
        lock.unlock();
    }
}

// 消费者线程
void consume() throws InterruptedException {
    lock.lock();
    try {
        while (queue.isEmpty()) {
            notEmpty.await(); // 消费者进入 notEmpty 的队列
        }
        queue.poll();
        notFull.signal();     // 从 notFull 队列唤醒一个生产者
    } finally {
        lock.unlock();
    }
}
```



## ReentrantReadWriteLock（读写锁）

简介：之前提到的锁都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在**同一时刻可以允许多个读线程访问**，但是**写线程访问时，所有的读线程和其它线程均被阻塞**。内部维护了一对锁，一个读锁和一个写锁，通过读写锁分离，相比其他一般的排他锁，性能有了很大的提升。

特性：

1. **公平性选择**：支持非公平和公平锁的获取。
2. **重入性**：读线程在获取读锁之后，能够再次获取读锁。而写线程在获取了写锁之后能够再次获取写锁，同时也可以获取读锁
3. **锁降级**：遵循获取写锁、获取读锁再释放写锁的次序，**写锁能够降级为读锁**。（指把当前拥有的写锁，再获取读锁，随后释放先前拥有的写锁的过程）

互斥规则：

- 写——写：互斥，一个线程在写的同时，其它线程会被阻塞。
- 读——写：互斥，读的时候不能写，写的时候不能读。
- 读——读：不互斥，不阻塞。

```java
public class ReadWriteDemo {
    //创建读写锁
    ReentrantReadWriteLock readWriteLock=new ReentrantReadWriteLock();
    private int value;
    //设置
    public void setValue(int value){
        //上锁
        readWriteLock.writeLock().lock();
        try {
            Thread.sleep(1000);
            this.value=value;
            System.out.println(Thread.currentThread().getId()+"修改了value:"+this.value);
        }catch (Exception e){
            e.printStackTrace();
        }
        finally {
            readWriteLock.writeLock().unlock();
        }
    }
    public int getvalue(){
        readWriteLock.readLock().lock();
        try {
            Thread.sleep(1000);
            System.out.println(Thread.currentThread().getId()+"读取了value:"+this.value);
            return value;
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        finally {
            readWriteLock.readLock().unlock();
        }
        return -1;
    }
​
    //测试代码
    public static void main(String[] args) {
        ReadWriteDemo readWriteDemo=new ReadWriteDemo();
        //修改
        for (int i = 0; i < 2; i++) {
            new Thread(()->{
                readWriteDemo.setValue(new Random().nextInt(100));
            }).start();
        }
        //读取
        for (int i = 0; i < 8; i++) {
            new Thread(()->{
                readWriteDemo.getvalue();
            }).start();
        }
    }
}
```



## StampedLock（读写性能之王且Java 8特性之一）

> StampedLock是Java8提供的一种乐观读写锁。相比于ReentrantReadWriteLock，StampedLock引入了乐观读的概念，**就是在已经有写线程加锁的同时，仍然允许读线程进行读操作，这相对于对读模式进行了优化，但是可能会导致数据不一致的问题，所以当使用乐观读时，必须对获取结果进行校验**。
>

##### StampedLock的三种模式

- **读模式**：在读模式下，**多个线程可以同时获取读锁，不互相阻塞**。但当写线程请求获取写锁时，读线程会被阻塞。与ReentrantReadWriteLock类似。
- **写模式**：写模式时独占的，**当一个写线程获取写锁时，其它线程无法同时持有写或读锁**。写锁请求会阻塞其它线程的读锁。与ReentrantReadWriteLock类似。
- **乐观读模式**：注意，上述两个模式均加了锁，所以它们之间读写互斥，**乐观读模式是不加锁的读**。这样就有两个好处，**一是不加锁意味着性能会更高一点，二是写线程在写的同时，读线程仍然可以进行读操作**。（如果对数据的一致性要求，那么在使用乐观读的时候需要进行**validate()校验**，可以看一下下面示例）

```java
public class StampedLockDemo {
    //假设这是需要操作的数据
    Map<String,String> map=new HashMap<>();
    //邮戳锁
    StampedLock lock=new StampedLock();
    public String optimisticRead(String key){
        //乐观读
        long stamp = lock.tryOptimisticRead();
        //读数据
        String value = map.get(key);
        //校验数据是否是最新版本
        if (!lock.validate(stamp)) {
            //校验失败（出现了数据不一致的情况），获取读锁（锁升级）
            stamp = lock.readLock();
            try {
                //重新读取数据并返回
                return map.get(key);
            }finally {
                lock.unlock(stamp);
            }
        }
        //没有出现数据不一致的情况，直接返回
        return value;
    }
}
```

### 比较

##### 锁的类型

- RRW：传统读写锁，提供了读锁和写锁两个类型。读锁支持多个线程同时读取共享资源，而写锁独占共享资源。读-读不互斥，读-写和写-写互斥。


- StampedLock： RRW的升级版，提供了读锁、写锁和乐观读三种类型的锁，其中读锁和写锁与RRW类似，乐观读则是对读操作的一个优化。


##### 互斥规则：

- RRW：读-读不互斥，读-写和写-写互斥。


- StampedLock：读锁和写锁之间互斥，但乐观读和写锁之间不互斥。


##### 并发性能：

- RRW：只有读-读才能并发，其它情况均互斥，所以性能良好。


- StampedLock：有乐观读，读-写可以并发，性能优秀。


##### 可重入性：

- RRW：可重入，当持有读锁的线程获取后，可以再次获取同一把读锁，持有写锁的线程获取锁后，可以再次获取写锁，同时也能获取读锁。


- StampedLock：不可重入，不论读锁还是写锁，都不可再次获取同一把锁。


##### 锁升级：

- RRW：支持锁降级，但要遵循获取写锁，获取读锁在释放写锁的次序，写锁才能降级为读锁。


- StampedLock：读锁和写锁之间可以通过tryConvertToReadLock(long stamp)和tryConvertToWriteLock(long stamp)方法之间相互转换。


##### 锁实现：

- RRW：基于AQS实现。


- StampedLock：基于CLH锁，一种自旋锁，保证没有饥饿且FIFO。




## CAS（乐观锁）

前面提到的都是悲观锁，悲观锁就是认定冲突一定发生，所以提前上把锁，而**乐观锁认为一般情况下不会造成冲突，所以在进行提交更新的时候，才会正式检测数据的冲突与否，如果冲突，则返回用户错误信息，让用户决定如何去做。**

CAS全称Compare And Swap，顾名思义就是先比较再交换。主要应用就是实现乐观锁和锁自旋。CAS操作包含三个操作数——**内存位置（V）、预期值（A）和新值（B）**。在并发修改的时候，会先比较A和V的值是否相等，如果相等，则会把值替换成B，否则就不做任何操作。

### CAS在操作系统层面的原子性

> **cmpxchg指令**是一条原子指令。在cpu执行cmpxchg指令时，**处理器会自动锁定总线，防止其它cpu访问共享变量**，然后执行比较和交换操作，最后释放总线。
>
> cmpxchg指令在执行期间，cpu会自动禁止中断。这样可以确保CAS操作的原子性，**避免中断或其它干扰对操作的影响**。
>
> cmpxchg指令是硬件实现的，可以保证其原子性和正确性。cpu中的硬件电路确保了cmpxchg指令的正确执行，以及对共享变量的访问原子性。

### CAS存在的问题

##### ABA问题

CAS算法实现一个重要**前提是需要取出内存中某时刻的数据，而在下个时刻进行比较和交换，那么这个时间差会导致数据的变化**。

比如，当线程1要修改A时，会先读取A的值，如果此时有一个线程2，经过一系列操作，将A修改为B，再由B修改为A，然后线程1在比较A时，发现A的值没有改变，于是就修改了。但此时A的版本已经不是最先读取的版本了，这就时ABA问题。

如何解决？解决这个问题的办法也很简单，**就是添加版本号，修改数据时带上一个版本号，如果版本号与数据的版本号一致就修改**（同时修改版本号），否则就失败。

##### 忙等待问题

因为CAS基本都是要自旋的，这种情况，如果并发冲突比较大的话，就会导致CAS一致不断地重复执行，导致进入忙等待。

所以，一旦CAS进入忙等待状态一直执行不成功的话，就会对CPU造成很大的性能开销。

如何解决？可以换用LongAdder类，它是Java 8中推出一个新的类，主要为了**解决CAS在并发冲突比较激烈的情况下性能并不高的问题**，它主要采用分段+CAS的方式来提升原子操作的性能，内部维护了一个cell[]数组和一个base变量，**CAS失败的操作先存储到此数组中用于分散计数，最后返回的值为base+cell数组中的个数**，但有最终值不准确的情况。



## Volatile关键字

1. ### 保证可见性，不保证原子性

   - ##### 当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主存中。

   - ##### 这个写操作会导致其他线程中的volatile变量缓存失效。

2. ### 禁止指令重排

   - ##### 重排序的操作不会对存在数据依赖关系的操作进行重排序。

   - ##### 重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变。

单例模式的双重锁

```java
public class TestInstance{
  private volatile static TestInstance instance;
  public static TestInstance getInstance(){   //1
    if(instance == null){   //2
      synchronized(TestInstance.class){   //3
        if(instance == null){   //4
          instance = new TestInstance(); //5
        }
      }
    }
    return instance;   //6
  }
}
```

```tex
a. memory = allocate() //分配内存
b. ctorInstanc(memory) //初始化对象
c. instance = memory   //设置instance指向刚分配的地址
```

在没有volatile修饰的情况下，当两个线程调用单例对象的实例化，线程A执行获得锁后进行对象的创建，但是重排序可能会导致先进行内存分配随后进行指向地址。此时线程B执行到2处判断对象不为空，跳到6处返回一个未初始化的对象。
