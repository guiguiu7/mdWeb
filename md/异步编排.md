## CompletableFuture

`CompletableFuture`可用于线程异步编排，使原本串行执行的代码，变为并行执行，提高代码执行速度。

使用`CompletableFuture`异步编排大多方法都会有一个重载方法，会多出一个executor参数，用来传来自定义的线程池，如果不传就会使用默认的线程池。

```java
public class testFuture {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // 创建一个线程池
        Executor executor = Executors.newFixedThreadPool(5);
        
        // 没有返回值
        CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
            System.out.println("Future is running in thread: " + Thread.currentThread().getName());
        }, executor);
        
        // 有返回值但会阻塞
        CompletableFuture<String> vFuture = CompletableFuture.supplyAsync(() -> {
            System.out.println("Future with return value is running in thread: " + Thread.currentThread().getName());
            int i = 10 / 0;
            return "ok";
        }, executor).whenComplete((v, e) -> {
            System.out.println("返回的结果: " + v + ", 异常: " + e);  // 可以获取返回的结果和异常
        }).exceptionally(e -> {
            return "error";  // 再出现异常时可以返回一个默认值
        });
        System.out.println("Future with return value result: " + vFuture.get());
    }
}
```

###### 可以使用handle来替代whenComplete和exceptionally两个方法，它可以获取返回值和异常并且能返回一个默认值。

###### 携带Async的方法后续会在另一个线程执行（可能会是同一个线程）



==allOf()方法需要使用.get()进行阻塞，否则会出现主线程提前完成而任务未执行成功的情况==