## 社交登录

QQ、微博、GitHub等网站的用户量非常大，别的网站为了简化自我网站的登陆与注册逻辑，引入社交登陆功能：

步骤：

1. 用户点击QQ按钮
2. 引导跳转到QQ授权页
3. 用户主动点击授权，跳回之前网页



## OAuth2.0

OAuth2.0是一个**开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息**，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。

对于用户相关的OpenAPI（例如获取用户信息，动态同步，照片，日志，分享等），为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。

### 使用Gitee为例，实现社交登录

1. ##### 登录Gitee官网，进入设置页面

2. ##### 找到第三方应用选项，打开

3. ##### 创建应用，填写好应用名称、主页、回调地址、logo等

4. ##### 保存应用后，可以看到Gitee自动为我们生生成了Client ID，以及Client Secret，之后会用到。

5. ##### Client向用户申请请求认证（本地项目跳转到Gitee登录界面），Gitee登录按钮的链接是下方的 URL

   - URL 中至少包含以下参数：

     - **client_id**：在Gitee开放平台申请的应用 ID

     - **redirect_uri**：授权成功后要跳转到的地址

6. ##### 用户授权，点击以上链接后跳转到Gitee的授权页面

7. ##### 用户使用上步授权，向授权服务器（Gitee）进行认证

8. ##### 授权服务器（Gitee）认证通过，返回访问令牌给Client

9. ##### Client使用访问令牌，向API服务器获取开放保护信息

   - 要包含以下参数：

     - **client_id**：在Gitee开放平台申请的应用 ID

     - **client_secret**：在Gitee开放平台申请时提供的APP Secret

     - **grant_type**：需要填写authorization_code

     - **code**：上一步获得的 code

     - **redirect_uri**：回调地址，需要与注册应用里的回调地址以及第一步的 redirect_uri 参数一致

       注：获取token十分重要，采用POST方式比较安全。

10. ##### API服务器认证令牌，返回Client受保护信息

    - 携带参数：

      - **access_token**：上一步获取的access_token

      - **uid**：用户的账号 id，上一步的接口有返回
        注：access_token使用时间有限



## Session

session在网络应用中称为“会话控制”，是服务器为了保存用户状态而创建的一个特殊的对象。简而言之，session就是一个对象，用于存储信息。 

**session是存储于服务器端的特殊对象**，服务器会为每一个游览器(客户端)创建一个唯一的session。这个**session是服务器端共享，每个游览器(客户端)独享的**。我们可以在session存储数据，实现数据共享，数据以key-value进行存放的。

![session.png](images%2Fcd56abf3fdb26d8f265e91a312803ef7.png)
***第一次客户端是没有JSESSIONID的，所以访问服务端判断没有这个id就会创建一个新的。如果id没有过期且没被删除，客户端再次发送http请求就会携带此id，否则会新建一个JSESSIONID***



**session常用方法**

- **resquest.getSession()**：得到请求游览器(客户端)对应的session。如果没有，那么就创建应该新的session。如果有那么就返回对应的session
- **setAttribute(String s, Object o)**：在session存放属性
- **getAttribute(String s)**：从session中得到s所对应的属性
- **removeAttribute(String s)**：从session中删除s对应的属性
- **getId()**：得到session所对应的id
- **invalidate()**：使session立即无效
- **setMaxInactiveInterval(int i)**：设置session最大的有效时间。注意，这个有效时间是两次访问服务器所间隔的最大时间，如果超过最大的有效时间，那么这个session就失效了。



##### session和cookie的比较

- cookie保存在**客户端**，session保存在**服务端**
- cookie作用于他所表示的path中(url中要包含path)，范围较小。session代表客户端和服务器的一次会话过程，web页面跳转时也可以共享数据，范围是本次会话，客户端关闭也不会消失。会持续到我们设置的session生命周期结束(默认30min)
- 我们使用**session需要cookie的配合**。cookie用来携带JSESSIONID（只有在域名不变的情况下session是共享的）
- cookie存放的**数据量较小**，session可以**存储更多的信息**。
- cookie由于存放在客服端，相对于session更不安全
- 由于session是存放于服务器的，当有很多客户端访问时，肯定会产生大量的session，这些session会对服务端的性能造成影响。



##### session存在的问题

- 不能跨域共享
- 同一个服务有多个，session存在不同步问题

##### 解决方案：

##### 1.session复制

- 优点
  - web-server（Tomcat）原生支持，只需要修改配置文件
- 缺点
  - session同步需要数据传输，占用带宽，降低服务器集群的业务处理能力
  - 任意一台web-server保存的数据都是所有web-server的session总和，受内存限制无法扩展更多的web-server
  - 大型分布式集群下，由于所有web-server都全量保存数据，所以不可取

##### 2.客户端存储

- 优点
  - 服务器不需存储cookie，用户保存自己的信息到cookie中。节省服务端资源
- 缺点
  - 每次http请求，携带cookie中用户完整信息，浪费网络带宽
  - session数据存在cookie中，cookie长度限制4KB，不能保存大量数据
  - session数据放在cookie中存在泄露、篡改、窃取等安全隐患

##### 3.hash一致性

##### 4.统一存储

- 优点
  - 没有安全隐患
  - 可以水平扩展，数据库/缓存水平切分
  - web-server重启或扩容都不会丢失session
- 缺点
  - 增加了一次网络请求，需要修改代码；例如需要从redis中查数据，相较于缓存中较慢。



##### 方案实现（使用Spring Session）

在客户端发送请求获取JSESSIONID时，服务端在redis中保存一份并且返回客户端时将作用域放大到父域名，所有子域名即可共享session

###### （通过装饰器模式实现）Session是自动续期的。但也存在不能跨域的问题。

##### 1.导入依赖

```xml
<dependency>
	<groupId>org.springframework.session</groupId>
	<artifactId>spring-session-data-redis</artifactId>
</dependency>
```

##### 2.@EnableRedisHttpSession启动

##### tip：前提需要先连接redis

```java
// 配置序列化
@Configuration
public class MySessionConfig {
    @Bean
    RedisSerializer<Object> springSessionDefaultRedisSerializer() {
        return new GenericJackson2JsonRedisSerializer();
    }
}
```

```java
@GetMapping("/testSession")
    public String testSession(HttpServletRequest request) {
        request.getSession().setAttribute("test","testValue");
        return "ok";
    }
```



## 单点登录（sso）

单点登录英文全称Single Sign On，简称就是SSO。它的解释是：**在多个应用系统中，只需要登录一次，就可以访问其他相互信任的应用系统**。例如，网页登录了淘宝账号，天猫，钉钉等阿里系应用都不用再二次登录了。 SSO核心意义就一句话：一处登录，处处登录；一处注销，处处注销。



##### 技术实现

1. 基于Cookie的单点登录
   - Cookie不安全
   - 不能跨域实现免登
2. 基于Session的单点登录（不推荐）



### 常见方案

### CAS

![实现流程.png](images%2F4acfa028a73fea761f42773603493e8c.png)

具体流程如下：

1. 用户访问app系统，app系统是需要登录的，但用户现在没有登录。

2. 跳转到CAS server，即SSO登录系统，以后图中的CAS Server我们统一叫做SSO系统。 SSO系统也没有登录，弹出用户登录页。
3. 用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。
4. SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。
5. app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。
6. SSO系统返回验证结果
7. 验证通过后，app系统将登录状态写入session并设置app域下的Cookie。

至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。

8. 用户访问app2系统，app2系统没有登录，跳转到SSO。

9. 由于SSO已经登录了（Cookie中已经存在ST），不需要重新登录认证。

10. 浏览器跳转到app2系统，并将ST作为参数传递给app2。

11. app2拿到ST，后台访问SSO，验证ST是否有效。

12. SSO系统返回验证结果
13. 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。
14. 这样，app2系统不需要走登录流程，就已经是登录了。SSO，app和app2在不同的域，它们之间的session不共享也是没问题的。



### JWT（客户端token）

##### token机制

其实，Token就是一串加密（使用MD5,等不可逆加密算法）的字符串。具体流程如下：

1.客户端使用用户名跟密码请求登录。

2.服务端收到请求，去验证用户名与密码。

3.验证成功后，服务端会签发一个加密的字符串（Token）保存到(Session,Redis,Mysql)中，并把这个Token发送给客户端。

4.客户端收到Token后存储在本地，如：Cookie 或 Local Storage 中。

5.客户端每次向服务端请求资源的时候需要带着服务端签发的 Token。

6.服务端收到请求，验证密客户端请求里面带着的 Token和服务器中保存的Token进行对比效验, 如果验证成功，就向客户端返回请求的数据。

使用Token验证的优势：

- 无状态、可扩展；
- 在客户端存储的Token是无状态的，并且可扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上；
- 安全性，请求资源时发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)

即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。



##### JWT 机制

JWT（JSON Web Token的缩写）它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证JWTToken的正确性，只要正确即通过验证。

- 紧凑：数据小，可以通过URL，POST参数，请求头发送。且数据小代表传输速度快。
- 自包含：使用payload数据块记录用户必要且不隐私的数据，可以有效的减少数据库访问次数，提高代码性能。
- JWT一般用于处理用户身份验证或数据信息交换。
- 用户身份验证：一旦用户登录，每个后续请求都将包含JWT，允许用户访问该令牌允许的路由，服务和资源。单点登录是当今广泛使用JWT的一项功能，因为它的开销很小，并且能够轻松地跨不同域使用。
- 数据信息交换：JWT是一种非常方便的多方传递数据的载体，因为其可以使用数据前面来保证数据的有效性和安全性。



##### JWT数据结构

JWT的结构包含三个部分： **Header头部，Payload负载和Signature签名**。三部分之间用“.”号做分割。 校验也是JWT内部自己实现的 ,并且可以将你存储时候的信息从token中取出来无须查库。

- ##### header

数据结构： {“alg”: “加密算法名称”, “typ” : “JWT”}

alg是加密算法定义内容，如：HMAC SHA256 或 RSA

typ是token类型，这里固定为JWT。

- ##### payload

在payload数据块中一般用于记录实体（通常为用户信息）或其他数据的。主要分为三个部分，分别是：**已注册信息（registered claims），公开数据（public claims），私有数据（private claims）**。

payload中常用信息有：**iss（发行者），exp（到期时间），sub（主题），aud（受众）**[等](https://tools.ietf.org/html/rfc7519#section-4.1)。前面列举的都是已注册信息。

公开数据部分一般都会在JWT注册表中增加定义。避免和已注册信息冲突。

公开数据和私有数据可以由程序员任意定义。

注意：即使JWT有签名加密机制，但是payload内容都是明文记录，除非记录的是加密数据，否则不排除泄露隐私数据的可能。**不推荐在payload中记录任何敏感数据**。

- ##### Signature

签名信息。这是一个由开发者提供的信息。是服务器验证的传递的数据是否有效安全的标准。在生成JWT最终数据的之前。先使用header中定义的加密算法，将header和payload进行加密，并使用点进行连接。如：加密后的head.加密后的payload。再使用相同的加密算法，对加密后的数据和签名信息进行加密。得到最终结果。



##### JWT执行流程

JWT的请求流程也特别简单，首先使用账号登录获取Token，然后后面的各种请求，都带上这个Token即可。具体流程如下：

1. 客户端发起登录请求，传入账号密码；

2. 服务端使用私钥创建一个Token；
3. 服务器返回Token给客户端；

4. 客户端向服务端发送请求，在请求头中该Token；

5. 服务器验证该Token；

6. 返回结果。

![JWT执行流程](images%2F84801e19d82240a0a4eeb91b2b98de5f.webp)

Token和JWT确实比较类似，只不过，Token需要查库验证token 是否有效，而**JWT不用查库，直接在服务端进行校验,因为用户的信息及加密信息,和过期时间,都在JWT里**，只要在服务端进行校验就行，并且校验也是JWT自己实现的。

##### ==注意==

通过加密后的数据是以base64进行编码的，相当于以明文的方式传输。验证需要通过以下方式（而不是decode()），否则不能判断数据是否伪造。

```java
JWTVerifier verifier = JWT.require(Algorithm.HMAC256("secretKey"))
        .withIssuer("guiguiu7")
        .build();
return verifier.verify(token);
```



##### JWT实现单点登录

1. 引入依赖

```xml
<dependency>
    <groupId>com.auth0</groupId>
    <artifactId>java-jwt</artifactId>
    <version>3.10.3</version>
</dependency>
```

2. 创建&验证JWT工具类

```java
public class JwtUtil {

    /**
     * Description: 生成一个jwt字符串
     * @param name    用户名
     * @param secret  秘钥
     * @param timeOut 超时时间（单位s）
     * @return java.lang.String
     */
    public static String encode(String name, String secret, long timeOut) {
        Algorithm algorithm = Algorithm.HMAC256(secret);
        String token = JWT.create()
                //设置过期时间为一个小时
                .withExpiresAt(new Date(System.currentTimeMillis() + timeOut))
                //设置负载
                .withClaim("name", name)
                .sign(algorithm);
        return token;
    }

    /**
     * Description: 解密jwt
     *
     * @param token  token
     * @param secret secret
     * @return java.util.Map<java.lang.String,com.auth0.jwt.interfaces.Claim>
     */
    public static Map<String, Claim> decode(String token, String secret) {
        if (token == null || token.length() == 0) {
            throw new CustomException("token为空:" + token);
        }
        Algorithm algorithm = Algorithm.HMAC256(secret);
        JWTVerifier jwtVerifier = JWT.require(algorithm).build();
        DecodedJWT decodedJWT = jwtVerifier.verify(token);
        return decodedJWT.getClaims();
    }
}
```

3. 登录验证拦截器(在其他服务中创建)

```java
@Component
@WebFilter(urlPatterns = "/**", filterName = "loginFilter")
public class LoginFilter implements Filter {

    private Logger logger = LoggerFactory.getLogger(this.getClass());

    @Value("${sso_server}")
    private String serverHost;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void destroy() {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;
        String token = httpServletRequest.getParameter("token");
        if (this.check(token)) {
            filterChain.doFilter(servletRequest, servletResponse);
        } else {
            HttpServletResponse response = (HttpServletResponse) servletResponse;
            String redirect = serverHost + "/login?redirect=" + httpServletRequest.getRequestURL();
            //response.setContentType("application/json;charset=utf-8");
            //response.setCharacterEncoding("utf-8");
            //response.getWriter().write(JSON.toJSONString(new ReturnEntity(-1, "未登录", null)));
            response.sendRedirect(redirect);
        }
    }

    private boolean check(String jwt) {
        try {
            if (jwt == null || jwt.trim().length() == 0) {
                return false;
            }
            JSONObject object = HttpClient.get(serverHost + "/checkJwt?token=" + jwt);
            return object.getBoolean("data");
        } catch (Exception e) {
            logger.error("向认证中心请求失败", e);
            return false;
        }

    }
}
```



##### JWT实现登录认证

1. 引入依赖

```xml
        <!--引入jwt-->
        <dependency>
            <groupId>com.auth0</groupId>
            <artifactId>java-jwt</artifactId>
            <version>3.9.0</version>
        </dependency>
```

2. JWT工具类

```java
package com.canrio.onlinemusic.utils;
 
import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.interfaces.DecodedJWT;
import org.springframework.stereotype.Component;
 
import java.util.Date;
 
@Component
public class TokenUtil {
 
    private static final long EXPIRE_TIME= 15*60*1000;
    private static final String TOKEN_SECRET="token123";  //密钥盐
 
    /**
     * 签名生成
     * @return
     */
    public static String sign(String name,String userId){
 
        String token = null;
        try {
            Date expiresAt = new Date(System.currentTimeMillis() + EXPIRE_TIME);
            token = JWT.create()
                    .withIssuer("auth0").withClaim("id","id")
                    .withClaim("username", name)
                    .withClaim("userId",userId)
                    .withExpiresAt(expiresAt)
                    // 使用了HMAC256加密算法。
                    .sign(Algorithm.HMAC256(TOKEN_SECRET));
        } catch (Exception e){
            e.printStackTrace();
        }
        return token;
 
    }
    /**
     * 签名验证
     * @param token
     * @return
     */
    public static boolean verify(String token){
 
        try {
            JWTVerifier verifier = JWT.require(Algorithm.HMAC256(TOKEN_SECRET)).withIssuer("auth0").build();
            DecodedJWT jwt = verifier.verify(token);
            System.out.println("认证通过：");
            System.out.println("issuer: " + jwt.getIssuer());
            System.out.println("username: " + jwt.getClaim("username").asString());
            System.out.println("userId: " + jwt.getClaim("userId").asString());
            System.out.println("id"+jwt.getClaim("id").asString());
            System.out.println("过期时间：      " + jwt.getExpiresAt());
            return true;
        } catch (Exception e){
            return false;
        }
    }
 
    public static String getId(String token){
 
 
            JWTVerifier verifier = JWT.require(Algorithm.HMAC256(TOKEN_SECRET)).withIssuer("auth0").build();
            DecodedJWT jwt = verifier.verify(token);
            String id = jwt.getClaim("userId").asString();
            return id;
 
        }
}
```

3. 登录拦截器

```java
package com.example.mybatixtest.interceptor;
 
import com.example.mybatixtest.utils.TokenUtil;
import org.springframework.http.HttpMethod;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
 
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
 
@Component
public class LoginInterceptor implements HandlerInterceptor {
 
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        if (HttpMethod.OPTIONS.toString().equals(request.getMethod())) {
            System.out.println("OPTIONS请求，放行");
            return true;
        }
        String token = request.getHeader("token");
        if(TokenUtil.verify(token)){
            return true;
        }
        // 失败我们跳转回登录页面
        request.setAttribute("msg","登录出错");
        request.getRemoteHost();
        request.getRequestDispatcher("/login").forward(request,response);
        return false;
    }
 
}
```

4. 注册登录拦截器

```java
package com.example.mybatixtest.config;
 
import com.example.mybatixtest.interceptor.LoginInterceptor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
 
@Configuration
public class WebConfig implements WebMvcConfigurer {
 
    @Autowired
    LoginInterceptor loginInterceptor;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
                registry.addInterceptor(loginInterceptor)
                        .addPathPatterns("/**")   //默认对所有请求进行拦截
                        .excludePathPatterns("/userLogin","/static/**");     //对login页面和静态资源不拦截
    }
}
```





### 短token（JWT）和长token（redis）

- 短 token 是**基于 JWT 的访问令牌**，设计目标是 “高频请求时无需查库，直接解析验证”。通过签名确保不可篡改，保证身份和权限校验。**设置过期时间短**，即使泄露token，滥用窗口期也很短，安全性高。

- 长 token 是**用于刷新短 token 的令牌**，设计目标是 “在短 token 过期时，无需用户重新登录即可获取新的短 token”。将长token保存到redis中，用于生成短token。设置过期时间长，只要token有效，用户无需频繁登录。



##### 核心流程

1. **登录时**：
   - 生成短 Token。
   - 生成并存储长 Token 到 Redis。
2. **请求时**：
   - 拦截器验证短 Token（先查黑名单，再验签名）。
3. **登出时**：
   - 将短 Token 加入黑名单；
   - 删除 Redis 中的长 Token。
4. **修改密码时**：
   - 将当前短 Token 加入黑名单。
5. **刷新 Token 时**：
   - 验证长 Token（查 Redis）；
   - 生成新的短 Token。

##### 后端代码

JWT工具类

```java
import io.jsonwebtoken.*;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

public class JwtUtils {
    private static final String SECRET_KEY = "your-jwt-secret-key-32-bytes-long-1234567890";
    private static final long SHORT_TOKEN_EXPIRE_TIME = 10 * 60 * 1000; // 10分钟

    /**
     * 生成短Token
     */
    public static String generateShortToken(String userId, String role) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId);
        claims.put("role", role);
        
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(userId)
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + SHORT_TOKEN_EXPIRE_TIME))
                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
                .compact();
    }

    /**
     * 验证短Token（先检查黑名单，再验证签名）
     */
    public static Claims validateShortToken(String token) {
        // 1. 检查黑名单
        if (TokenBlacklist.isTokenRevoked(token)) {
            throw new ExpiredJwtException(null, null, "Token已被撤销");
        }
        
        // 2. 验证签名和过期时间
        try {
            return Jwts.parser()
                    .setSigningKey(SECRET_KEY)
                    .parseClaimsJws(token)
                    .getBody();
        } catch (SignatureException e) {
            throw new RuntimeException("无效签名");
        } catch (ExpiredJwtException e) {
            throw new RuntimeException("Token已过期");
        }
    }

    /**
     * 获取Token剩余有效期（毫秒）
     */
    public static long getRemainingTime(String token) {
        Claims claims = Jwts.parser()
                .setSigningKey(SECRET_KEY)
                .parseClaimsJws(token)
                .getBody();
        Date expiration = claims.getExpiration();
        return expiration.getTime() - System.currentTimeMillis();
    }
}
```

redis工具类

```java
import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.JedisPoolConfig;
import java.util.UUID;

public class RedisUtils {
    private static final JedisPool jedisPool;
    private static final String REFRESH_TOKEN_PREFIX = "refresh_token:";
    private static final String REVOKED_TOKEN_PREFIX = "revoked_tokens:";
    private static final int LONG_TOKEN_EXPIRE_TIME = 30 * 24 * 60 * 60; // 30天

    static {
        JedisPoolConfig poolConfig = new JedisPoolConfig();
        poolConfig.setMaxTotal(100);
        poolConfig.setMaxIdle(10);
        poolConfig.setMinIdle(5);
        jedisPool = new JedisPool(poolConfig, "localhost", 6379);
    }

    /**
     * 存储刷新Token
     */
    public static String saveRefreshToken(String userId, String device) {
        String refreshToken = UUID.randomUUID().toString().replace("-", "");
        String value = String.format("{\"userId\":\"%s\",\"device\":\"%s\",\"createdAt\":%d}",
                userId, device, System.currentTimeMillis());
        
        try (Jedis jedis = jedisPool.getResource()) {
            jedis.setex(REFRESH_TOKEN_PREFIX + refreshToken, LONG_TOKEN_EXPIRE_TIME, value);
        }
        return refreshToken;
    }

    /**
     * 获取刷新Token对应的用户ID
     */
    public static String getUserIdByRefreshToken(String refreshToken) {
        try (Jedis jedis = jedisPool.getResource()) {
            String value = jedis.get(REFRESH_TOKEN_PREFIX + refreshToken);
            if (value == null) return null;
            
            // 简化解析，实际项目建议用JSON库
            int start = value.indexOf("\"userId\":\"") + 10;
            int end = value.indexOf("\"", start);
            return value.substring(start, end);
        }
    }

    /**
     * 删除刷新Token（登出时调用）
     */
    public static void deleteRefreshToken(String refreshToken) {
        try (Jedis jedis = jedisPool.getResource()) {
            jedis.del(REFRESH_TOKEN_PREFIX + refreshToken);
        }
    }

    /**
     * 将短Token加入黑名单
     */
    public static void addToBlacklist(String shortToken) {
        try (Jedis jedis = jedisPool.getResource()) {
            String tokenHash = hashToken(shortToken);
            long remainingTime = JwtUtils.getRemainingTime(shortToken) / 1000; // 转为秒
            jedis.setex(REVOKED_TOKEN_PREFIX + tokenHash, (int) remainingTime, "1");
        }
    }

    /**
     * 检查短Token是否在黑名单中
     */
    public static boolean isTokenRevoked(String shortToken) {
        try (Jedis jedis = jedisPool.getResource()) {
            String tokenHash = hashToken(shortToken);
            return jedis.exists(REVOKED_TOKEN_PREFIX + tokenHash);
        }
    }

    /**
     * 生成Token的哈希值（防泄露原始Token）
     */
    private static String hashToken(String token) {
        // 实际项目建议用SHA-256等安全哈希算法
        return String.valueOf(token.hashCode());
    }
}
```

黑名单工具类

```java
public class TokenBlacklist {
    /**
     * 将Token加入黑名单
     */
    public static void revokeToken(String token) {
        RedisUtils.addToBlacklist(token);
    }

    /**
     * 检查Token是否在黑名单中
     */
    public static boolean isTokenRevoked(String token) {
        return RedisUtils.isTokenRevoked(token);
    }
}
```

认证控制器

```java
import org.springframework.web.bind.annotation.*;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api")
public class AuthController {

    /**
     * 登录接口
     */
    @PostMapping("/login")
    public Map<String, String> login(@RequestBody LoginRequest request) {
        // 验证用户名密码（略）
        String userId = "10086";
        String role = "user";
        
        // 生成短Token
        String shortToken = JwtUtils.generateShortToken(userId, role);
        
        // 生成并存储长Token
        String longToken = RedisUtils.saveRefreshToken(userId, request.getDevice());
        
        Map<String, String> result = new HashMap<>();
        result.put("shortToken", shortToken);
        result.put("longToken", longToken);
        return result;
    }

    /**
     * 刷新Token接口
     */
    @PostMapping("/refresh")
    public Map<String, String> refresh(@RequestBody RefreshRequest request) {
        String longToken = request.getLongToken();
        
        // 验证长Token
        String userId = RedisUtils.getUserIdByRefreshToken(longToken);
        if (userId == null) {
            throw new RuntimeException("无效的刷新Token"); // 需要重新登录
        }
        
        // 生成新的短Token
        String shortToken = JwtUtils.generateShortToken(userId, "user");
        
        Map<String, String> result = new HashMap<>();
        result.put("shortToken", shortToken);
        return result;
    }

    /**
     * 登出接口（主动失效短Token和长Token）
     */
    @PostMapping("/logout")
    public void logout(@RequestBody LogoutRequest request) {
        // 1. 将短Token加入黑名单
        String shortToken = request.getShortToken();
        if (shortToken != null) {
            TokenBlacklist.revokeToken(shortToken);
        }
        
        // 2. 删除长Token
        String longToken = request.getLongToken();
        if (longToken != null) {
            RedisUtils.deleteRefreshToken(longToken);
        }
    }

    /**
     * 修改密码接口（主动失效当前短Token）
     */
    @PostMapping("/changePassword")
    public void changePassword(@RequestBody PasswordChangeRequest request) {
        // 1. 验证旧密码，设置新密码（略）
        
        // 2. 将当前短Token加入黑名单
        String shortToken = request.getShortToken();
        if (shortToken != null) {
            TokenBlacklist.revokeToken(shortToken);
        }
        
        // 3. 注意：这里没有版本号机制，其他设备的Token仍有效
        // 如需让所有设备下线，可记录用户最后修改密码时间，验证时比对
    }
}

// 请求DTO类
class LoginRequest {
    private String username;
    private String password;
    private String device;
    
    // getters and setters
}

class RefreshRequest {
    private String longToken;
    
    // getters and setters
}

class LogoutRequest {
    private String shortToken;
    private String longToken;
    
    // getters and setters
}

class PasswordChangeRequest {
    private String userId;
    private String oldPassword;
    private String newPassword;
    private String shortToken;
    
    // getters and setters
}
```

JWT拦截器

```java
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.web.servlet.HandlerInterceptor;
import io.jsonwebtoken.Claims;

public class JwtInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, 
                             HttpServletResponse response, 
                             Object handler) throws Exception {
        // 1. 从请求头获取短Token
        String token = request.getHeader("Authorization");
        if (token == null || !token.startsWith("Bearer ")) {
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Missing token");
            return false;
        }
        token = token.substring(7);
        
        try {
            // 2. 验证短Token（自动检查黑名单和签名）
            Claims claims = JwtUtils.validateShortToken(token);
            
            // 3. 将用户信息存入请求属性
            request.setAttribute("userId", claims.get("userId"));
            request.setAttribute("role", claims.get("role"));
            
            return true;
        } catch (Exception e) {
            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, e.getMessage());
            return false;
        }
    }
}
```

拦截器

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new JwtInterceptor())
                .addPathPatterns("/api/**")
                .excludePathPatterns("/api/login", "/api/refresh");
    }
}
```



##### 核心逻辑

1. **请求拦截器**：
   每次请求前自动从`localStorage`获取短 token，添加到`Authorization`请求头（格式：`Bearer <shortToken>`）。
2. **响应拦截器**：
   - 检测到`401`错误（短 token 无效 / 过期）时，触发刷新逻辑；
   - 使用长 token 调用`/refresh`接口，获取新的短 token；
   - 刷新成功后，重试所有等待的请求，并更新本地存储的短 token；
   - 刷新失败（长 token 无效）时，清除本地 tokens 并跳转到登录页。
3. **并发控制**：
   通过`isRefreshing`标记和`failedQueue`队列，避免同时发起多个刷新请求，确保所有等待的请求使用同一个新 token 重试。
4. **登出处理**：
   调用后端`/logout`接口，将短 token 加入黑名单并删除长 token，同时清除本地存储的 tokens。

##### 前端代码

Token 管理工具类

```javascript
// tokenManager.js：封装Token存储和获取逻辑
const TOKEN_KEYS = {
  SHORT_TOKEN: 'short_token',
  LONG_TOKEN: 'long_token'
};

export const tokenManager = {
  // 存储短token
  setShortToken: (token) => {
    localStorage.setItem(TOKEN_KEYS.SHORT_TOKEN, token);
  },
  
  // 获取短token
  getShortToken: () => {
    return localStorage.getItem(TOKEN_KEYS.SHORT_TOKEN);
  },
  
  // 存储长token
  setLongToken: (token) => {
    localStorage.setItem(TOKEN_KEYS.LONG_TOKEN, token);
  },
  
  // 获取长token
  getLongToken: () => {
    return localStorage.getItem(TOKEN_KEYS.LONG_TOKEN);
  },
  
  // 清除所有token（登出时用）
  clearTokens: () => {
    localStorage.removeItem(TOKEN_KEYS.SHORT_TOKEN);
    localStorage.removeItem(TOKEN_KEYS.LONG_TOKEN);
  }
};
```

Axios 拦截器配置（自动刷新 Token）

```js
// api.js：配置Axios实例和拦截器
import axios from 'axios';
import { tokenManager } from './tokenManager';
import { router } from './router'; // 假设使用Vue Router或React Router

// 创建Axios实例
const api = axios.create({
  baseURL: 'http://localhost:8080/api', // 后端接口基础地址
  timeout: 5000
});

// 请求拦截器：添加短token到请求头
api.interceptors.request.use(
  (config) => {
    const shortToken = tokenManager.getShortToken();
    if (shortToken) {
      config.headers.Authorization = `Bearer ${shortToken}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// 响应拦截器：处理token过期并自动刷新
let isRefreshing = false; // 防止并发刷新请求
let failedQueue = []; // 存储等待刷新的请求

// 重试队列中的请求
const processQueue = (error, token = null) => {
  failedQueue.forEach(prom => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token);
    }
  });
  failedQueue = [];
};

api.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    
    // 若不是401错误或已重试过，直接抛出
    if (
      !error.response || 
      error.response.status !== 401 || 
      originalRequest._retry
    ) {
      return Promise.reject(error);
    }
    
    // 若没有长token，直接跳登录页
    const longToken = tokenManager.getLongToken();
    if (!longToken) {
      tokenManager.clearTokens();
      router.push('/login'); // 跳转到登录页
      return Promise.reject(error);
    }
    
    // 正在刷新token时，将请求加入队列
    if (isRefreshing) {
      return new Promise((resolve, reject) => {
        failedQueue.push({ resolve, reject });
      })
        .then(token => {
          originalRequest.headers.Authorization = `Bearer ${token}`;
          return api(originalRequest);
        })
        .catch(err => Promise.reject(err));
    }
    
    // 标记正在刷新
    originalRequest._retry = true;
    isRefreshing = true;
    
    try {
      // 调用refresh接口获取新的短token
      const response = await api.post('/refresh', {
        longToken: longToken
      });
      const { shortToken } = response.data;
      
      // 存储新的短token
      tokenManager.setShortToken(shortToken);
      
      // 重试队列中的请求
      processQueue(null, shortToken);
      
      // 重试原始请求
      originalRequest.headers.Authorization = `Bearer ${shortToken}`;
      return api(originalRequest);
    } catch (refreshError) {
      // 刷新失败，清空队列并跳登录页
      processQueue(refreshError, null);
      tokenManager.clearTokens();
      router.push('/login');
      return Promise.reject(refreshError);
    } finally {
      isRefreshing = false; // 刷新结束
    }
  }
);

export default api;
```

登入登出

```js
// authService.js：登录和登出接口调用
import api from './api';
import { tokenManager } from './tokenManager';

// 登录
export const login = async (username, password, device) => {
  const response = await api.post('/login', {
    username,
    password,
    device // 如"android"、"ios"、"web"
  });
  const { shortToken, longToken } = response.data;
  
  // 存储tokens
  tokenManager.setShortToken(shortToken);
  tokenManager.setLongToken(longToken);
  
  return response.data;
};

// 登出
export const logout = async () => {
  const shortToken = tokenManager.getShortToken();
  const longToken = tokenManager.getLongToken();
  
  try {
    // 调用后端登出接口（将短token加入黑名单，删除长token）
    await api.post('/logout', {
      shortToken,
      longToken
    });
  } finally {
    // 无论后端是否成功，都清除本地tokens
    tokenManager.clearTokens();
  }
};
```
